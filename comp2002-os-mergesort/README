# Assignment 3 - Parallel Merge Sort

* Authors: Hai Trung Do (a1899443), Tri Dung Nguyen (a1899360), Viet Bach Tran (a1901793)
* Group name: Group 80

## Overview

This project implements a multi-threaded parallel merge sort algorithm using the pthread library. The program sorts randomly-generated integer arrays by recursively dividing work across multiple threads up to a specified cutoff level, demonstrating significant performance improvements over single-threaded merge sort through concurrent execution.

## Manifest

* `mergesort.c` - Core implementation of parallel and serial merge sort functions
* `mergesort.h` - Header file with function prototypes and data structures
* `test-mergesort.c` - Main testing program for performance benchmarking
* `test_merge_advanced.c` - Advanced test suite for various input patterns
* `test_merge_boundary.c` - Edge case and boundary condition tests
* `test_merge_stress.c` - Large-scale stress testing program
* `test_basic.c` - Basic functionality validation tests
* `Makefile` - Build configuration
* `README.md` - This documentation file
* `run_all_tests.sh` - Script to execute all test programs sequentially

## Building the project

Build the project:
```bash
make
```

Clean build artifacts:
```bash
make clean
```

The build produces the `test-mergesort` executable along with additional test programs.

## Features and usage

**Core functions:**
- `mergesort()` - Single-threaded recursive merge sort
- `merge()` - Merges two sorted subarrays efficiently
- `parallel_mergesort()` - Multi-threaded merge sort using pthreads
- `buildArgs()` - Constructs thread argument structures

**Key features:**
- Configurable parallelization depth via cutoff levels
- Thread-safe implementation with proper synchronization
- Memory leak-free execution (verified with Valgrind on Linux or leaks on macOS)
- Speedup of 3-5x depending on cutoff level

**Run all tests at once:**
```bash
./run_all_tests.sh
```
This script automatically builds and executes all test programs in sequence, providing comprehensive validation of the implementation.

**Building additional tests individually:**
```bash
# Build all test programs
make tests

# Build specific test programs
make test_basic
make test_merge
make test_merge_advanced
make test_merge_boundary
make test_merge_stress
```

**Usage:**
```bash
./test-mergesort <array_size> <cutoff_level> <random_seed>
```

**Example:**
```bash
./test-mergesort 100000000 5 1234
```
Sorts 100 million elements using parallel merge sort with thread creation depth of 5.

**Running additional tests:**
```bash
./test_basic 1000 2 1234              # Basic functionality test
./test_merge                          # Merge function isolation test
./test_merge_boundary                 # Boundary condition tests
./test_merge_advanced                 # Advanced pattern tests
./test_merge_stress                   # Stress and performance tests
```

## Testing

### Correctness validation

**Basic functionality tests:**
- Tested array sizes: 10, 100, 1,000, and 10,000 elements
- Verified sorting correctness with `is_sorted()` validation
- Tested cutoff levels 0-2 across all sizes
- Result: 100% pass rate

**Boundary conditions:**
- Single and two-element arrays
- Already sorted and reverse-sorted arrays
- Arrays with duplicate values and negative numbers
- Empty subarrays during recursion
- Result: All 10 boundary cases passed

**Advanced scenarios:**
- Multiple random seeds (1234, 5678, 9999, 42, 12345)
- Special patterns: ascending, descending, alternating, uniform values
- Consistency across cutoff levels 0-5
- Result: 20+ test scenarios, 100% passed

### Performance benchmarking

**100 million element tests (seed 1234):**
- Cutoff 0 (serial): 17.10 seconds (baseline)
- Cutoff 1: 12.61 seconds (1.36x speedup)
- Cutoff 2: 5.40 seconds (**3.17x speedup** - meets requirement)
- Cutoff 3: 4.63 seconds (3.69x speedup)
- Cutoff 4: 3.41 seconds (5.01x speedup)
- Cutoff 5: 3.42 seconds (5.00x speedup)
- Cutoff 6: 3.34 seconds (**5.12x speedup** - optimal)

**Key findings:**
- Required 2x speedup achieved at cutoff level 2
- Optimal performance at cutoff 6 (approximately 5x)
- Diminishing returns beyond cutoff 6 due to thread overhead
- Results confirmed on Gradescope

### Stress and robustness testing

**Memory management:**
- Valgrind verification (Linux): `valgrind --leak-check=full ./test-mergesort 1000 2 1234`
- macOS alternative: `leaks -atExit -- ./test-mergesort 1000 2 1234`
- Result: "All heap blocks were freed -- no leaks are possible" / "0 leaks for 0 total leaked bytes"
- Proper allocation in `buildArgs()` and deallocation in `parallel_mergesort()`

**Thread synchronization:**
- Verified proper `pthread_join()` behavior across all cutoff levels
- No race conditions detected
- No zombie threads observed
- Tested with cutoff levels 0-8

**Stress tests:**
- Arrays from 10,000 to 100,000 elements
- 50 iterations with random sizes (1,000-10,000) and random cutoffs (0-3)
- Result: 50/50 tests passed (100% success rate)

### Testing summary

**Total test coverage:**
- Basic tests: 8 cases (100% passed)
- Boundary tests: 10 cases (100% passed)
- Advanced tests: 20+ scenarios (100% passed)
- Stress tests: 50+ iterations (100% passed)
- Manual tests: 30+ configurations (100% passed)

All testing confirms correct sorting behavior and required performance specifications are exceeded.

## Known bugs

No known bugs at the time of submission. The implementation successfully sorts arrays of all tested sizes and consistently achieves the required >2x speedup on Gradescope.

## Reflection and self assessment

**Key challenges:**
- Grasping the concept of "indirect recursion" where `parallel_mergesort()` calls itself through `pthread_create()` rather than direct function calls
- Managing memory allocation and deallocation across multiple threads to prevent leaks
- Identifying the optimal cutoff level where thread creation overhead begins to outweigh parallelization benefits
- Ensuring proper thread synchronization without introducing race conditions

**Learning and research:**
- Studied pthread API documentation extensively, focusing on `pthread_create()` and `pthread_join()` semantics
- Researched merge sort mechanics and the necessity of auxiliary arrays for efficient merging
- Investigated thread overhead and context switching costs that cause diminishing returns
- Learned best practices for memory management in multi-threaded C programs

**Key insights:**
- The binary tree visualization of thread creation helped clarify the cutoff level concept
- Performance doesn't scale linearly with thread count - overhead eventually dominates
- Proper memory cleanup is critical in threaded applications to prevent leaks
- Comprehensive testing (especially boundary cases) is essential for robust concurrent code

**Development experience:**
Development proceeded smoothly after understanding the overall architecture. We implemented serial merge sort first, thoroughly tested it, then incrementally added parallelization. The testing phase proved crucial for identifying synchronization and memory issues. Team collaboration enabled effective task division and collaborative debugging, making the project manageable and educational.

## Sources used

1. Operating Systems: Three Easy Pieces - Chapters 26 and 27 (Concurrency and threads API)
- http://pages.cs.wisc.edu/~remzi/OSTEP/

2. pthread API man pages:
- pthread_create: https://man7.org/linux/man-pages/man3/pthread_create.3.html
- pthread_join: https://man7.org/linux/man-pages/man3/pthread_join.3.html

3. Memory leak detection tools:
- Valgrind documentation (Linux): https://valgrind.org/docs/manual/quick-start.html
- macOS leaks man page: https://www.manpagez.com/man/1/leaks/

4. Merge sort algorithm tutorial:
- HackerRank Merge Sort video: https://www.youtube.com/watch?v=4VqmGXwpLqc